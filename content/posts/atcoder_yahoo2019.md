---
title:      "Atcoder: みんなのプロコン2019"
date:       2019-02-09T22:20:24+09:00
categories: ["competitive_programming"]
tags:       ["contest","atcoder"]
draft:      false
---

恒例の不参加．

# A. Anti-Adjacency

選ぶ数の最大値をなるべく小さくしたいことから，1から1つ飛ばしで数を選んでいくのが最適．このとき$k$個目$(k=1,...)$の数は$k$番目の正奇数，すなわち$2k-1$であるから，これと$n$との大小を比較する．https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4220931

# B. Path

問題文の処理をそのまま実装するDFSを書いた．道に番号を振ってそれぞれの道を通ったかを配列で記録しておけば，3回の移動で「すべての道を」「1回ずつ」通ったかは迷いなく判断可能．https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4220932

editorialの解法は一応紙に書いて確かめるとそれっぽいのだけど洩れを作りそうで怖い．

# C. When I hit my pocket...

こういう操作の特性を考える系の問題は何も浮かばないことが多い気がする．実験をした．https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4220933

本文中にある操作を上からP,Q,Rとする．円を持っていても仕方がないので操作Q,Rの数は同数．すると例えば操作列は`PPPQRPPQQRRP...`のようになるが，`P...PQR...QR`と整列して構わない．このとき`P`の数を$p$，`QR`の数を$q$とすると，$p+2q=k$．
このときのスコアは$p+1+(b-a)q$ $= (k-2q)+1+(b-a)q$ $= (b-a-2)q+k+1$．

$q$の係数が負または0，すなわち$b-a \le 2$の場合は$q$が少ないほうがよく，$q=0$としてスコアは$k+1$．そうでない場合は$q$は多いほうが良い．ただし操作Qを行う条件として$p \ge a-1$，変形して$q \le \frac {k-a+1} {2}$が必要であり，$q = \lfloor \frac {k-a+1}{2} \rfloor$としてスコアを算出すればよい．ここで$q \ge 0$にも注意：$q$が負のときは$q=0$とする．

<!-- ここで$a$が大きいと$q$も負になるが，$b-a-2$も負になることに注意：これにより$(b-a-2)q \gt 0$となり異常な解が現れる場合があるため[^c1]，$q \ge 0$も見る必要がある． -->

最初は$p$について整理しようとして散々な目に遭った．$q= \frac{k-p}{2}$を用いると$p+1+(b-a)q$ $= p+1+(b-a)(k-p)$ $= p(1-(b-a))+1+(b-a)k$．$b-a \gt 1$のときは$p$の係数が負なので操作Q,Rを増やすべきだが，操作Qを行う条件として$p \ge a-1$．素直に$p=a-1$としたいが，$q$は整数なので$k-(a-1)$の偶奇で場合分け：偶数のときはそのまま$q=\frac {k-(a-1)}{2}, p=a-1$．奇数のときは$q = \lfloor \frac{k-(a-1)} {2} \rfloor$としてしまうと1操作余るため，それを操作Pに回して$p=a, q=\frac {k-a} {2}$とする．こちらのほうが面倒．

ところでeditorialでは最初から$b-a \le 2$かを見ている．これは操作QR（スコア$+(B-A)$）と操作PP（スコア$+2$)の比較と見れば納得できる：$b-a \le 2$であれば後者を選んだほうがよく，$b - a \ge 2$であれば前者を選んだほうが得をする．

# D. Ears

~~ここまでくると流石に寒い~~．散歩が1回だけという条件を読み落としていたが，そうでなくても解けなかったと思う．

## 解説(editorialなど)

まず散歩により耳がどうなるかを考えると，これは[$0$]<sup>\*</sup>-[偶数$\ge 2$]<sup>\*</sup>-[奇数]<sup>\*</sup>[^d1]-[偶数$\ge 2$]<sup>\*</sup>-[$0$]<sup>\*</sup>という$5$つの区間が並んだ形になる．この導出は[こちらのブログ](https://betrue12.hateblo.jp/entry/2019/02/10/014031)が詳しい．書いてあるように一番単純な形から考えてみるのがよさそう．以下についても参考にしている．他にも参考記事があるが後掲する．

[^d1]: 始端=終端のとき長さ$0$もあり得る．

本問で行う操作は次の2つ：

1. 散歩によって耳$i$の石の個数を$b[i]$とする
2. 各$b[i]$に好きな回数$\pm 1$をし，$b[i]=a[i]$とする

各$a[i]$が散歩のときどの区間だったのかを考える．先に述べた区間を順に$Z_l,E_l,O,E_r,Z_r$とする[^d2]．
前の数字が区間$A$であるとすると区間の順序から次の数字は$A$以降の種類のどれかになるはずであり，逆にどれになっても構わない[^d3]．

[^d3]: $Z_l$と$Z_r$，および$E_l$と$E_r$は条件として同じであるから，より自由度の高い左側を優先することで計算を減らせるとのこと．とはいえそうしなくてもACできる．

[^d2]: $O$がゼロの区間に見えてしまうので微妙い．

$a[i]$が当て嵌まる区間の種類を仮定すると必要な操作の回数もわかる：

* $a[i]$が$Z_l$:
	* $b[i]=0$から$a[i]$回操作を行って$a[i]$にしたはず．
* $a[i]$が$E_l$:
	* $b[i]$は2以上の偶数．したがって$a[i]=0$のとき操作は$2$回（$b[i]=2$として$-2$する），2以上の偶数のとき$0$回（そのまま），奇数のとき$1$回（$b[i]=a[i]+1$とする）．
* $a[i]$が$O$:
	* $b[i]$は奇数であるから，$a[i]$が奇数であれば操作は$0$回，でなければ$1$回（$b[i]=a[i]+1$とする）．
* $a[i]$が$E_r$: $E_l$と同様．
* $a[i]$が$Z_r$: $Z_l$と同様．

肝心の区間を決めたい．なんか以前に「区間の境界を1つ決めると残りの境界も決まる」というのを見たことがあるが今回はたぶんそうはならない．DPができる：$dp[i][K] := $「$a[i]$が区間$K$であるときの操作回数の最小値」とすると，先に説明したように区間の遷移を書ける．すなわち区間$K$に対して先の操作回数を$f_K (a[i])$，$K$またはそれ以前の区間を$P(K)$とおくと：

$$dp[i+1][K] \gets \min_{J \in P(K)} \\{ dp[i][J] + f_J (a[i]) \\}$$

となる．配るDPとして解釈したほうが先の記述に合っているが，配るDPを式で書くときの慣例がよくわからず．
計算量は$K$が5通りなので$O(L)$．考察さえ済めばかなり綺麗に書ける．https://atcoder.jp/contests/yahoo-procon2019-qual/submissions/4262826

あまりDPを知らないので説明自体はそんなにできないが，遷移のために参照すべき情報が「前の番地の区間種別」だけであるからそれが等しい状態を一つに纏めてよい，ということなのかしら．

## 参考

* https://betrue12.hateblo.jp/entry/2019/02/10/014031
* http://koba-e964.hatenablog.com/entry/2019/02/10/003030