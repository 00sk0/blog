---
title:      "Atcoder: Nikkei Programming Contest 2019"
date:       2019-01-27T22:37:02+09:00
categories: ["competitive_programming"]
tags:       ["contest","atcoder"]
draft:      false
---

コンテストに出るのは難しい（睡眠時間を調整しなければならない！）．不参加．

<!--more-->

# A. Subscribers

難しい．https://atcoder.jp/contests/nikkei2019-qual/submissions/4112889

$m=|X \cap Y|$の最大値および最小値を求める問題．最大値が$\min \\{|X|,|Y|\\}$なのはまあわかる．最小値には「どちらも購読していない人たちが$0$人以上でなければならない」という条件が入る：$|X \cup Y|=a+b-m$より，先の人数は$n-(a+b-m) \ge 0$，移項して$m \ge a + b - n$が必要．加えて$m \ge 0$であるから，連立させて$m \ge \max \\{(a+b-n), 0\\}$となる．

# B. Touitsu

最初なんとなくどれかに揃えれば良さそうな気がしたがそんなことは無かった（サンプルを先に見ろ）．$a,b,c$の$i$文字目について多数決を採ればよい．どれも異なればコストは+2, 1ペアだけあれば+1, すべて揃っていれば+0．https://atcoder.jp/contests/nikkei2019-qual/submissions/4112885

# C. Diffrent Strokes

前にも見た気がする．https://atcoder.jp/contests/nikkei2019-qual/submissions/4112886

高橋くんが目標を実現するための手段としては「自分のスコアを大きくする」以外に「青木さんのスコアを小さくする」もある．ここから考えると，高橋くんが$a[i]$番目を取ると青木さんは$b[i]$を取れないから高橋くんは$a[i]+b[i]$だけ得すると考えられる．よって$(a[i]+b[i],i)$をソートし，これが大きい順から$a[i]$を取ればよい．青木さん視点でも同様に考えれば$(b[i]+a[i],i)$の大きい順から取りたいこととなる．したがって先のソート結果から二人して大きい順に取って行き，高橋くんの手番ではスコアに+$a[i]$を，青木さんの手番では-$b[i]$していけばよい．

## editorial

解説では片方の得点だけを考えてよいようにゲームを変形している．青木さんが$\sum b[i]$をすべて食べた状態，すなわち高橋くんのスコアが$-\sum b[i]$の状態から高橋くんが$i$を選んで自分のスコアに$a[i]+b[i]$加算するゲームを考えても等価．こうすることで$a[i]+b[i]$でソートすればよいという考察の見通しが良くなりそう．この手法も割と見た気がするので定着させたい．

# D. Restore the Tree

トポロジカルソートは[この前やった](/posts/cf_532)こともあり使いそうだとは思ったもののどう使えばいいかわからず撤退．というか寝惚けてて閉路ができるのではと疑ってしまったのだが全くそんなことは無かった（木構造に対して親から子孫に矢印を引くので子孫から親方向の辺が作られることはない）．

## 解説(editorial?)

https://atcoder.jp/contests/nikkei2019-qual/submissions/4112887

根からトポロジカルソートすると（根は入力辺が無い点を調べればすぐに求まる），その結果はすべての辺のin/out順に並んでいる．いま要素$v$に入る辺が$p,q$（出現順序もこの通りとする）から出ているとき，元々の木に存在した辺は$q \to v$．

証明（editorialが分からなかったので独自解釈，したがって誤りがありそう）：$p \rightarrow v$が元々の辺だったとすると，操作によって$q \rightarrow v$を引く条件から元々の木にも$q$から$v$に至る経路が存在することとなる．$q$はトポロジカルソートで$p$より後ろであることから$p$の先祖とはならず[^d1]，また$p$の子孫にもなれない[^d2]ため，$q$から$v$への経路が$p$から$v$への辺と独立に存在することとなる．これは元の木構造に合流地点$v$があることを意味するため不適．一方で$q \rightarrow v$が元々の辺であるとすれば$p$から$v$への経路は$q \rightarrow v$を含むように作れるため（逆にそうでなければ先のように合流地点が存在してしまう），問題なく操作によって$p \rightarrow v$を引くことが可能．辺の出自が$p_1,p_2,...,p_l,q$と3頂点以上の場合も各$p_i$と$q$に対して同様の議論を適用すれば$q \rightarrow v$以外あり得ないことが分かりそう．

最初トポロジカルソートにおいて右側の要素の深さは左の要素と同等またはそれ以上だと勝手に思っていたのだがそんなことはない（wikipediaの図からも分かる）．木構造でも片方の子を深く掘れば反例が作れる．

全然関係ないがAtCoderでもCodeforcesでも提出したコードを正常にハイライトしてくれないの悲しい．OCamlに限った話かは分からないけれど．

[^d1]: $q$から$p$に到達する経路$q \rightarrow s_1 \rightarrow ... \rightarrow s_k \rightarrow p$（$k \ge 0$）があるとすると$q$と$s_i$はこの順にトポロジカルソートに表れ，かつ$s_k$が$p$の前に存在することから$q$が$p$より前に表れることとなり矛盾．

[^d2]: 辺$p \rightarrow v$が元々の木にあったことから$p$は$v$の直属の親．$v$より深くに$q$が存在するはずもなく．

## 別解

本番で思いついたものの考えきれずに捨てた解法だったがこれでも正解できるようだ．各頂点について根からの距離が最長となるような経路が元の木の経路となる．理由としては操作によって追加される辺は先祖から子孫を繋ぐ，すなわち根からの距離を減少させるようにしか張れないことが挙げられそう．これにより距離最大以外の経路を採用すると最大長の経路が作れなくなって矛盾する．合っているかはわからない．

今回のようなDAGの最長経路の求め方を検索すると，トポロジカルソートを利用したものが出てくる．[GeeksforGeeks](https://www.geeksforgeeks.org/find-longest-path-directed-acyclic-graph/)によると，トポロジカルソート順に頂点を調べ，そこを始点とする辺の終点について距離を更新していけばよいとのこと．理由が書かれていないので推測：通り過ぎた頂点に対して新たに最長経路が見つかるとそこから到達する頂点すべてに対して再計算が必要になるが，トポロジカルソート順だと一度通り過ぎた点はもう使われないために再計算が起こらないから？ https://atcoder.jp/contests/nikkei2019-qual/submissions/4113005

ところで提出を眺めていると上位陣にこれをBFSで求めている解答が散見された[^d11]．
BFSのアルゴリズムを思い出すと，BFS順で最後に点$v$に到達するときが根から$v$までの最長経路となる（最短経路から順に見つかっていくので）．したがってBFS順で最後になるまでは無視し，最後になったらようやく遷移をすればよい．最後かどうかは$v$に到達する辺の個数を数えておけば判断可能で，このときに親ノードを記録し，遷移をしていく．重みが一定の場合にしか使えなそうだが考え方として面白かった．https://atcoder.jp/contests/nikkei2019-qual/submissions/4113002

[^d11]: https://atcoder.jp/contests/nikkei2019-qual/submissions/4100659 など．

最初は「根からDFSをして各頂点に対して根からの最長距離を記録しておけば，もう一度DFSをすることでその情報から経路を復元できる」という方針を立てていたのだがこの方針だと例の再計算を何回も行うことになりTLE．



