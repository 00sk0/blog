---
title:      "Educational Codeforces #57"
date:       2018-12-29T14:52:23+09:00
categories: ["competitive_programming"]
tags:       ["codeforces", "contest","ocaml"]
draft:      false
---

参加記録を書いてみます．とりあえず本番で解いたA,B,Cについて．editorialが出たらDも<del>追記します</del><ins>→追記しました</ins>．

# [A. Find Divisible](https://codeforces.com/contest/1096/problem/A)

難しかった． https://codeforces.com/contest/1096/submission/47657942

とりあえず$x=l,l+1,...$と固定することにすると，$y$の候補は$y=2x,3x,...$となる．ここで$y$は$[l,r]$内に収めたいことから$y$は最小値を取るべき，すなわち$y=2x$とするべきだと分かる．すると候補は$x$の値に対応して$(x,y)=(l,2l),(l+1,2(l+1)),...$となるが，同様に$y$は最小であってほしいから$(x,y)=(l,2l)$を選べばよい．

# [B. Substring Removal](https://codeforces.com/contest/1096/problem/B)

AtCoderの64bit環境に慣れきってしまい，オーバーフローが起きていることに気づくまでに30分+4WAほど空費（+1WA: modの取り忘れ）． https://codeforces.com/contest/1096/submission/47658038

<!-- 連続区間を削除するということは左からl文字と右からr文字だけ残すということ． -->
隣り合う同じ文字で組を作ったときに（例: abbaaならa,bb,aa）組が3つ以上できる場合，両端以外の組は必ず消去しなければならないことに注意（a,b,a,b,aaのような場合でも中央のaだけ残して両隣のbを消すような芸当はできない）．そこで両端の組の文字および個数を調べておく．

## 両端の組の文字が異なる場合

例として`aacdeee`を選ぶと，両端の組は`aa`,`eee`となる．この場合は一方の組をすべて消す必要がある．左側をすべて消すとすると，全体としては次のような残し方がある（消した文字を`_`とする．消すものが連続区間であることに注意[^cont]）：

* `__,__,eee`
* `__,__,_ee`
* `__,__,__e`
* `__,__,___`

右側も同様：

* `aa,__,___`
* `a_,__,___`
* `__,__,___`

空文字列が重複しているから全体では$4+3-1=6$通り．一般には左右の組の文字数を$l,r$とすれば$(l+1)+(r+1)-1$通りと求まる．最初に除外した2組だけの場合も同じ式で求まるため，場合分けの必要はない．

[^cont]: 中央を必ず消すのだから削除区間が中央にあり，その区間の左端右端をそれぞれ右左に伸ばすこととなる．よって左の組については右から0,1,...文字消すこととなる．右も同様．

## 両端の組の文字が同じ場合

例として`aaabaa`を選ぶと両端の組は`aaa,aa`となる．この場合，一方を完全に消す必要はない．すなわち「左の組からi文字，右の組からj文字消す」ような消し方となる：

* `aaa,_,aa`
* `aa_,_,aa`
* `a__,_,aa`
* `___,_,aa`
* `aaa,_,_a`
* `aa_,_,_a`
* `a__,_,_a`
* `___,_,_a`
* `aaa,_,__`
* `aa_,_,__`
* `a__,_,__`
* `___,_,__`

いま左は$3$文字，右は$2$文字．よって左を$0 \sim 3$文字消して右を$0 \sim
 2$文字消すことが可能で，これらは独立だから$(3+1)\*(2+1)=12$通り．一般には左右の組の文字数を$l,r$とすれば$(l+1)\*(r+1)$通りと求まる．

# [C. Polygon for the Angle](https://codeforces.com/contest/1096/problem/C)

本番は場合分けに失敗した導出方法[^a]だったがACではあった． https://codeforces.com/contest/1096/submission/47658098

入力が$d$，答えが正$n$角形であるとする．中心を$O$，頂点を時計回りに$0,...,n-1$とする．いま対称性より3頂点$(a,b,c)$を$(0,j,k) (0 \lt j \lt k \lt n)$と選ぶ．

まず一般に正$n$角形の隣り合う頂点$p,q$について$∠pOq=360/n$である．求めるのは円周角$∠abc$．円周角の定理より円周角は対応する中心角の1/2である．したがって$∠abc=\frac{∠aOc}{2}=\frac{360(n-k)/n}{2}=180(n-k)/n$となる[^c]．よって解くべきは$180(n-k)/n=d$，変形して$180k=(180-d)n (0 \lt j \lt k \lt n)$となる．

この一次不定方程式を解く．といっても定数項がないので$gcd(180,180-d)$で割って係数を互いに素にすればよい：$pk=qn$．すると正数解は$(n,k)=(p,q),(2p,2q),...$となる．

答えは最小の$n$であるから$(n,k)=(p,q)$でよさそうに見えるが，$j$の存在を忘れてはならない：頂点$0,j$が存在するため実際は$k \ge 2$が必要．したがって$q=1$のときは$(2p,2q)$を採用し，そうでないときは$(p,q)$とする．

なお，$180 \gt 180-d$より$p \gt q$であり必ず$k \lt n$となっていること，および$n$の最大値が$360$（$p$の最大値は$180-d$と$180$がはじめから互いに素のときで$180$．$d=179$のとき$q=1$となるため$n=2p=360$）であることから，解なしはあり得ない．

[^c]: $∠abc$に対応する$∠aOc$の値として採用すべきなのは鈍角であろうとなかろうと$360(n-k)/n$（数学ができなすぎて悩んでしまったが当たり前ではある……）．


[^a]: aとb,bとcの間が180°を超えない場合?のみについて考えていた：$∠aOb,∠bOc$はそれぞれ$360j/n,360(k-j)/n$となる．ところで$⊿aOb,⊿bOc$はそれぞれ二等辺三角形であるから$∠abO,∠cbO$が求まる：$(180-(360j/n))/2, (180-(360(k-j)/n))/2$．この場合は図よりこれらの和を取れば$∠abc$と等しくなるから$∠abc=180-180k/n=d$となり，変形して$180k=(180-d)n$．これは本文と同じ式．

# [D. Easy Problem](https://codeforces.com/contest/1096/problem/D)

指定された文字列を組み立てる方法の総数を求める問題は見たことがあったため，この問題もそれに近いだろうと一度はDPを考えた．ところが今回求めるものは逆に文字列を作らないための最小コストであることからか混乱して，状態をどう持つべきか思いつけなかった．

## 解法(editorial)

$dp[i][j] := $「文字列の左から$i$文字目までにおいて，"hard"の$j$文字目まで作ってしまっている（$j=0$のときは空文字列とする）ときの最小コスト」とする．すると求める値は$\min_{i \in [0,3]} dp[n][i]$とできる． https://codeforces.com/contest/1096/submission/47816104

こうして見ると文字を組み立てるときと結構同じ気がする．とするとなぜ解けなかったか気になるが，「文字を作らない」という条件の言い換えが上手くできなかったことが失敗要因かもしれない（文字を作るときのように途中状態に分解して考えればよかった，のかしら）．

追記：文字列を作る過程をDFAと見ると，求めたい値は$dp[$受理状態$]$の中にある．文字列を完成させた場合の最少スコアを求めたい場合は受理状態が文字列の完成した状態$j=4$になる一方，今回の受理状態は文字列が完成していない状態$j=0,1,2,3$．

実装については，今まではINFに`Int64.max_int`を採用していたため，これに値を足したものがオーバーフローして負になりバグらせてしまった．他の解決法もいくつか浮かんだものの，色々なsubmitを眺めた結果どうやらINFに$10^{18}$あたり（`1L<<60`など）を採用すればよさそうな感じがあり，今後はそうしていきたい．



