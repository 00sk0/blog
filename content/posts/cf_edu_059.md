---
title:      "Educational Codeforces #59"
date:       2019-01-27T03:35:38+09:00
categories: ["competitive_programming"]
tags:       ["contest","codeforces"]
draft:      false
---

不参加ではあるがABCの3問を30分程度で解いた（テストせず＋Aで1WAなので割と嘘）．しばらくはコンテスト自体にはあまり出場しない予定だが（実力的に頭打ち感があるので先に練習を重ねたい．ただしAtCoderの日経コンテストは気になる），問題を解くのはそれなりに楽しめているし続けていきたい．

# A. Digits Sequence Dividing

ABCの中で一番難しい．CodeforcesのA問題では殆どの場合に適用できる最適解（端を取ったり中央を取ったりソートしたり2の倍数だったり）＋コーナーケースの処理みたいなのを割と見た気がしていて，今回もそれ．発想みたいなのが苦手なのでどう解けばいいのか迷う．練習あるのみな気はする．https://codeforces.com/contest/1107/submission/49036441

左を1桁だけ残して2つの数に分割すると，$n_i \ge 3$であれば必ず条件が達成できる（右のほうが桁が多くなるので必ず右のほうが大きい）．$n_i = 2$のときは左$ \lt $右であれば条件に合うが，それ以外，すなわち左$ \ge $右のとき不適．このとき他に分割しようもないので無理だと分かる．

# B. Digital root

https://codeforces.com/contest/1107/submission/49036481

一見難しそうに見えたのだが$S(x)$と$x$の関係を表にしてみれば一目瞭然という感じ：

	 1  2  3  4  5  6  7  8  9
	10 11 12 13 14 15 16 17 18
	19 20 21 22 23 24 25 26 27
	28 29 30 31 32 33 34 35 36
	37 38 39 40 ..

すると求めるべき「$S(m)=x$となる$k$番目の$m$」は表の$x$列目の上から$k$番目の数．従って$m = x + 9 \times (k-1)$．

# C. Brutality

CodeforcesのC問題の難易度の基準がわからない．https://codeforces.com/contest/1107/submission/49036533

同じボタンを$k$回連続で押してしまうと駄目ということは，同じボタンの連続部分についてはその中の$k$個しか選べないということ．逆に他のボタンの部分や同じボタンでも何か挟んだ位置のものについては気にしなくてよい[^c1]．従って各ボタンの連続部分を独立に考え，その中の最大$k$個を取ればよい．単純にソートしても間に合った．

[^c1]: 離れた位置の同じボタンについて：最大値を得たいという条件から，例えば`aaabbaa`のような配置のときに`b`を1つも選ばない理由は無い．よって左右の部分にある`a`は絶対に連続せず，独立に考えられる．

競プロをしていると文字列をfoldしたくなることがあるのだけど標準ライブラリには見当たらず，時間との兼ね合いで破壊的に書いてしまうことが多い（[本番コード](https://codeforces.com/contest/1107/submission/49024700)）．文字列を配列に変換して（`Array.init n (fun i -> s.[i])`でよい）`fold_left`なりをするかせめて再帰関数で書いていきたい[^c2]が，時間制限があると焦りからかこうなってしまう．結果的に書く時間はそれほど変わらない気もするのだが．掲載コードは再帰関数．

[^c2]: 関数型言語のお作法に明るくないので「`fold`で書けるが取り回す変数が煩雑になるときに，[それでもなお`fold`すべきか](https://codeforces.com/contest/1107/submission/49036739)，又は[再帰関数を用いるべきか](https://codeforces.com/contest/1107/submission/49036533)（掲載コード）」がよく分かっていない．自分は上述の通りコンテスト中は破壊してしまいますが……．

# D. Compression

数学をしていないので$\lceil x \rceil$が切り上げか切り捨てか分からなくなったが右クリック→Show Math As→TeX Commandsしたら分かりやすくなった．何で切り上げ？と思ったけど1-indexedだからそれはそう．これも前回と同じくAC数だけ見て撤退したのだが，落ち着いて見たら特に難しくなかった．https://codeforces.com/contest/1107/submission/49042035

要するに行列を同じサイズの正方形のピースに分割したとき各ピースの中身がすべて0かすべて1であるようなサイズの最大値を求めたい．2次元累積和を取りさえすれば，ある範囲内がすべて1であるか，すべて0であるか，1と0が混ざっているかが$O(1)$で分かる．各ピースに対してこれを試し，前2つであれば問題なく圧縮可能，でなければ失敗．あとはピースのサイズを試していけばよい．候補は$n$の約数なので$O(\sqrt{n})$で求まり，これを大きい順に試す．

計算量解析をせずにだいたい調和級数のあれの二乗だから間に合うんじゃないかなで投げてしまった．累積和づくりに$O(n^2)$，約数生成に$O(\sqrt{n})$であり，これらは普通に間に合う．最後の約数を順に試すところの最悪計算量を考えると，約数の数を$d$として$O(1^2 + ... + \frac{n}{2^2} + n ^ 2) = O(n^2 (\frac {1} {n^2} + ... + \frac {1} {2^2} + 1))$となり，例の$\sum_{k=1}^{n} {\frac{1}{k^2}}$が出てくる．これは収束するので$O(n^2)$．

頭が悪くて$n$の約数を二分探索してしまったがどう考えても単調ではない[^d1]．そんなこんなで2WAほど．

[^d1]:
	分割が2の倍数のものばかり試していたから気付けなかった説もある．
	たとえば次の行列ではサイズ3で分割できるが，2では不可能：
	```
	111000111000
	111000111000
	111000111000
	000111000111
	000111000111
	000111000111
	111000111000
	111000111000
	111000111000
	000111000111
	000111000111
	000111000111
	```
